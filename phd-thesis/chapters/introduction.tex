%!TEX root = /Users/gilesb/UofC/thesis/phd-thesis/phd-thesis.tex
\chapter{Introduction}
\section{Background}
\label{sec:background}

Reversible computing, at the level of Turing machines, was shown to be equivalent to standard
computing by Bennet \cite{bennett:1973reverse} in 1973. In the past fifteen or so years, there has
been an increased interest in reversible computing, perhaps engendered by the obvious relationship
to Quantum computing (e.g., \cite{neilsen2000:QuantumComputationAndInfo}) where computation is done
by a series of unitary transforms, each of which is reversible, followed by an irreversible
measurement.

The semantics of reversible computing has been examined in a variety of ways. Broadly, they may be
broken into two classes. The first class consists of those that introduce a reversible
language and then describe the semantics of that language in some way. Examples of this include
Zuliani, \cite{zuliani01:reversibility} and Mu et.al., \cite{muetal04:injreversible}. The second
class focus on some algebraic model and then introduce reversibility to that model. Examples of this
include Abramsky \cite{abramsky05:reversible}, Di Pierro et.al. \cite{DiPierro200625}, Danos and
Krivine \cite{danos2004reversible} and Phillips and Uladowski \cite{phillips2006operational}.

An important aspect of the treatment of reversible computing is the consideration of partiality in
programs, i.e., it is possible for programs to not return an answer for certain inputs. The above
references consider partiality to a greater or lesser degree, but none of them treat it as a central
consideration.

Partiality was shown to have an algebraic treatment, restriction categories, by Cockett and Lack in
\cite{cockett2002:restcategories1,cockettlack2003:restcategories2,cockettlack2004:restcategories3}.

\subsection{Algebraic models of reversibility}
\label{subsec:algebraic_models_of_reversibility}
In \cite{abramsky05:reversible}, Abramsky considers Bi-orthogonal automata as his computational
model. (An automata is considered orthogonal if it is non-ambiguous and left-linear. It is
bi-orthogonal when the automata and its converse are both orthogonal). He then builds a bridge from
partial injective and involutive functions to these automata. To show universality, he provides
specific constructions of bi-orthogonal automata that create a Linear Combinatory Algebra
\cite{abramsky02:GOI}.

In \cite{danos2004reversible}, Danos and Krivine extend CCS (Calculus for Communicating Systems)
\cite{milner1980calculus,milner1989communication} to produces RCCS, which adds reversible
transitions to CCS. This is done by adding a syntax for backtracking, together with a labelling
which guides the backtracking. The interesting aspect of this paper is the applicability to
multi-processor programs.

Phillips and Uladowski \cite{phillips2006operational} take a different approach to creating a
reversible CCS from that of Danos and Krivine. Rather, their stated goal is to use a structural
approach, inspired by \cite{abramsky05:reversible}. The paper is only an initial step in this
process, primarily explaining how to turn dynamic rules (such as choice operators) into a series of
static rules that keep all the information of the input. For example (from the paper), in standard
CCS, we have the rule
\[
  \infer{X+Y \to X'}{X\to X'}.
\]
To preserve information and allow reversibility, this is replaced with
\[
  \infer{X+Y \to X' +Y}{X\to X'}.
\]


\subsection{Reversible languages}
\label{subsec:reversible_languages}
An early example by
Zuliani, \cite{zuliani01:reversibility}, examines logical reversibility via extending $pGCL$
\cite{MorganIver99} and comparing to $qGCL$ \cite{sanders:quantum}. He provides a method for
transforming an irreversible $pGCL$ program into a reversible one. He accomplishes this via an
application of expectation transform semantics to the $pGCL$ program. Interestingly, he specifically
excludes partial programs from his definition of reversible programs. The paper provides a
translation for a $pGCL$ program into a reversible one. The initial definition of a reversible
program is initially strict, i.e., the program is equivalent to $skip$ which does nothing. To
alleviate this and allow us to extract the output, he follows the example of
\cite{bennett:1973reverse} and modifies the result so that the output is copied before reversing the
rest of the program.

In \cite{mu06bidirectional} and \cite{muetal04:injreversible}, Mu et.al. introduce the language
\textbf{Inv}, a language that is composed only of partial injective functions. The language has an
operational semantics based on relations and converses. They provide a variety of examples of the
language, including translations from XML to HTML and simple functions such as $wrap$, which wraps
its argument into a list. Additionally they describe how non-injective functions may be converted to
injective ones in \textbf{Inv} via the addition of logging. In fact, they use this logging to argue
the language is equivalent in terms of power to the reversible Turing machine of
\cite{bennett:1973reverse}.

The approach to this language is perhaps the most explicitly like the theory presented in this
Thesis. Their approach of insisting on injective functions is a specific case of an inverse
category. When given two functions $f,g$ of \textbf{Inv}, constructing their union, $f\cup g$
requires that both $\dom f \cap \dom g = \nothing$ and $\rng f \cap \rng g = \nothing$. This
compares favourably to our introduction of the disjoint join in Section~\ref{sec:disjoint_joins}.

A more recent entry into the field of reversible languages is that of Theseus,
\cite{james2014theseus}, by Sabry and James. Theseus is a functional language which compiles to
$\PI$ as presented in \cite{james2012information,james2013isomorphic}.
\section{Objectives}
\label{sec:objectives}

\section{Contributions}
\label{sec:contributions}

The initial contribution of this thesis is the characterization of inverse categories with products
and coproducts.
We show in Proposition~\ref{prop:an_inverse_category_with_products_is_a_restriction_preorder}
and Proposition~\ref{prop:inverse_category_with_coproducts_is_pre-order} that each of products and
coproducts impose a trivialization of the structure of the base category.

The main contributions of this thesis are:
\begin{enumerate}
\item The definition and characterization of the inverse product in an inverse category (known as a
  discrete inverse category) and showing  that it provides meets for the inverse category.
\item The creation of an equivalence relation on a discrete inverse category and showing that the
  category resulting from factoring out the equivalence relation is a discrete Cartesian restriction
  category.\label{item:contribution-2}
\item Showing that the category of discrete inverse categories is equivalent to the category of
  discrete Cartesian restriction categories.
\item The development of disjointness relations and disjoint joins in inverse categories and how
  they arise from suitable monoids over the inverse category.
\item Showing that inverse categories with disjoint joins and restriction zeroes (called inverse sum
  categories) give rise to a matrix category and that the original inverse sum category is
  equivalent to the matrix category.
\item The proof that a distributive inverse category (one with inverse products and disjoint joins
  where the inverse product distributes over the disjoint join) gives a distributive restriction
  category when factoring out the equivalence relation from Item~\ref{item:contribution-2} above.
\end{enumerate}

\section{Outline} % (fold)
\label{sec:outline}

We assume a knowledge of basic algebra including definitions and properties of groups, rings,
fields, vector spaces and matrices. The reader may consult \cite{lang:algebra} if further details
are needed.

Chapter~\ref{chap:abstract_computability} introduces the various concepts that will be used
throughout this thesis. The basics of category theory are reviewed in Section~\ref{sec:categories}
followed by an introduction to restriction categories in
Section~\ref{sec:restriction_categories}. Section~\ref{sec:daggercategories} and
Section~\ref{sec:frobenius_algebras}  introduce dagger categories and Frobenius
algebras respectively. These constructs are of particular interest in the study of quantum semantics
and will provide a source of examples for us.

Chapter~\ref{cha:inverse_categories} starts with showing that inverse categories with a restriction
product collapse into a restriction pre-order, that is, all parallel maps agree wherever they are
both defined. Section~\ref{sec:inverse_products} introduces the concept of inverse products and
explores the properties of inverse categories with these constructions. Inverse categories with
inverse products are labelled discrete inverse categories. A major example of discrete inverse
categories, commutative Frobenius algebras is then introduced in
Section~\ref{sec:the_category_of_commutative_frobenius_algebras}.
Section~\ref{sec:completing_a_discrete_inverse_category} then explores how to construct a Cartesian
restriction category based on a discrete inverse category, culminating in
Theorem~\ref{thm:discrete_inverse_categories_are_equivalent_to_discrete_restriction_categories}
giving an equivalence adjunction between discrete inverse categories and discrete Cartesian
restriction categories, which were introduced in Sub-Section~\ref{sub:discrete_restriction_categories}.

Having explored how to introduce a product-like construction in an inverse category,
Chapter~\ref{cha:disjointness_in_inverse_categories} begins the exploration of how to add a
coproduct-like construction. Paralleling the previous chapter, in
Section~\ref{sec:coproducts_in_restriction_categories} we show that restriction coproducts
impose an even greater amount of structure on an inverse category. The existence of a restriction
coproduct implies that an inverse category must be a pre-order, i.e., that all parallel maps are
equal. Section~\ref{sec:disjointness_in_an_inverse_category} starts with a quick review of joins in
restriction categories, followed by defining a disjointness relation in an inverse category. We show
that disjointness may be defined on all maps or equivalently only on the restriction idempotents of
the inverse category. This allows us to now define the disjoint join in
Section~\ref{sec:disjoint_joins}. We then conclude this chapter with
Section~\ref{sec:tensors_for_disjointness} showing how specific conditions on a symmetric monoidal
tensor in an inverse category allow us to define both a disjointness relation and a disjoint join
from that tensor.

Chapter~\ref{cha:inverse_sum_categories} builds upon the previous chapters to introduce
coproduct-like constructions into the inverse
category. Section~\ref{sec:disjointness_in_frobenius_algebras} starts by expanding the example of
commutative Frobenius algebras, showing there is a disjointness relation in them. In
Section~\ref{sec:inverse_sum_categories} we explore the relationship between disjoint joins and
inverse sums. This culminates in showing that an inverse category \X with a tensor generating disjoint
joins gives rise to a matrix category over \X and that \X is equivalent to its matrix
category. Finally, in Section~\ref{sec:completing_a_distributive_inverse_category} we show that the
construction introduced in Section~\ref{sec:completing_a_discrete_inverse_category} also lifts an
inverse sum up to a coproduct and in fact will create a distributive restriction category when the
inverse product distributes over the disjoint join.

Our conclusions and thoughts for potentially interesting areas to explore further are then given in
Chapter~\ref{cha:conclusions_and_future_work}.



% section algebraic_setting (end)
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../phd-thesis"
%%% End:
