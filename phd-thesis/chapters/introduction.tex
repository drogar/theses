%!TEX root = /Users/gilesb/UofC/thesis/phd-thesis/phd-thesis.tex
\chapter{Introduction}\label{chap:introduction}
\section{Summary}\label{sec:summary}
A ``quantum'' setting has a fundamental duality given by the ``dagger'' of dagger
categories\cite{selinger05:dagger,abramsky05:abstractscalars}. On the other hand, classical
computation is fundamentally asymmetric and has no duality. In passing from a quantum setting to a more classical setting, one
may want to keep this duality for as long as possible and, thus, consider the intermediate step of
passing to ``reversible'' computation --- which has an obvious self-duality given by the ability to
reverse the computation. It is reasonable to
wonder whether one can then pass from a reversible setting to a classical setting quite
independently from the underlying quantum setting. Such an abstract
passage would allow a direct translation into the reversible world of the classical notions of
computation, for example.

Of course, from a quantum setting, it is already possible to pass directly to a classical setting by
taking the homomorphisms between special coalgebras, where ``special'' means the coalgebra must be
the algebra part of a separable Frobenius algebra. That the coalgebra should be special in this manner
may be justified by regarding this as a two step process through reversible computation. However,
this leaves some gaps: How does on pass, in general, between a quantum setting to a reversible
setting and how does one obtain a classical setting from a reversible setting? This thesis answers
those questions.
\section{Background}
\label{sec:background}

The semantics of reversible computing has been examined in a variety of ways. Broadly, they may be
broken into two classes. The first class consists of those that introduce a reversible
language and then describe the semantics of that language in some way. Examples of this include
Zuliani, \cite{zuliani01:reversibility} and Mu et.al., \cite{muetal04:injreversible}. The second
class focuses on some algebraic model and then introduces reversibility to that model. Examples of this
include Abramsky \cite{abramsky05:reversible}, Di Pierro et.al. \cite{DiPierro200625}, Danos and
Krivine \cite{danos2004reversible} and Phillips and Uladowski \cite{phillips2006operational}.

Reversible computing, at the level of Turing machines, was shown to be equivalent to standard
computing by Bennet \cite{bennett:1973reverse} in 1973. Since approximately 2000, there has
been an increased interest in reversible computing. This may have been engendered by the obvious relationship
to Quantum computing (e.g., \cite{neilsen2000:QuantumComputationAndInfo}) where computation is done
by a series of unitary transforms, each of which is reversible, followed by an irreversible
measurement.

An important aspect of the treatment of reversible computing is the consideration of partiality in
programs, i.e., it is possible for programs to not return an answer for certain inputs. The above
references consider partiality to a greater or lesser degree, but none of them treat it as a central
consideration.

Partiality was shown to have an algebraic treatment, restriction categories, by Cockett and Lack in
\cite{cockett2002:restcategories1,cockettlack2003:restcategories2,cockettlack2004:restcategories3}. The
algebraic treatment consists of an operator on maps, denoted by a bar over the map, such that for a
map $f:A\to B$ in a category, then $\rst{f}:A\to A$ is an idempotent map in the category. Full
details are given here in Section~\ref{sec:restriction_categories}.

In much of the research on reversibility, specific conditions are placed on some aspect of the
computational model or reversible language to ensure ``programs'' in this model are reversible. Due
to the variety of models and languages it is unclear what are the common threads of these restrictions.
We contend that our treatment of the theory of reversibility will provide the basis to show
relationships between a variety of approaches.

\subsection{Algebraic models of reversibility}
\label{subsec:algebraic_models_of_reversibility}
In \cite{abramsky05:reversible}, Abramsky considers bi-orthogonal automata as his computational
model. (An automata is considered orthogonal if it is non-ambiguous and left-linear. It is
bi-orthogonal when both the automata and its converse are both orthogonal). Abramsky then builds a
bridge from partial injective and involutive functions to these automata. To show universality,
specific constructions of bi-orthogonal automata are provided which create a Linear Combinatory Algebra
\cite{abramsky02:GOI}.

In \cite{danos2004reversible}, Danos and Krivine extend CCS (Calculus for Communicating Systems)
\cite{milner1980calculus,milner1989communication} to produces RCCS, which adds reversible
transitions to CCS. This is done by adding a syntax for backtracking, together with a labelling
which guides the backtracking. The interesting aspect of this paper is the applicability to
multi-processor programs.

Phillips and Uladowski \cite{phillips2006operational} take a different approach to creating a
reversible CCS from that of Danos and Krivine. Rather, their stated goal is to use a structural
approach, inspired by \cite{abramsky05:reversible}. The paper is only an initial step in this
process, primarily explaining how to turn dynamic rules (such as choice operators) into a series of
static rules that keep all the information of the input. For example (from the paper), in standard
CCS, we have the rule
\[
  \infer{X+Y \to X'}{X\to X'}.
\]
To preserve information and allow reversibility, this is replaced with
\[
  \infer{X+Y \to X' +Y}{X\to X'}.
\]


\subsection{Reversible languages}
\label{subsec:reversible_languages}

Early examples of reversible languages include Janus \cite{lutz1986janus}, an imperative language
written as an experiment in producing a language that did not erase information. We were unable to
find any evidence of a semantics for this language.

Additionally, there are special purpose reversible languages, such as biXid \cite{bixid06}, a
language developed explicitly to transform XML \cite{xml} from one schema to another. The main
novelty of biXid is that a single program targets two schemas and will transform in either direction.

In the realm of languages which possess an explicit semantics, we start with Zuliani
\cite{zuliani01:reversibility}, who examines logical reversibility via extending $pGCL$
\cite{MorganIver99} and comparing to $qGCL$ \cite{sanders:quantum}. Zuliani provides a method for
transforming an irreversible $pGCL$ program into a reversible one. This is accomplished via an
application of expectation transform semantics to the $pGCL$ program. Interestingly, partial
programs are specifically excluded from the definition of reversible programs. The initial
definition of a reversible program is strict, i.e., the program is equivalent to $skip$
which does nothing. To alleviate this and allow us to extract the output, Zuliani follows the example of
\cite{bennett:1973reverse} and modifies the result so that the output is copied before reversing the
rest of the program.

In \cite{mu06bidirectional} and \cite{muetal04:injreversible}, Mu et.al. introduce the language
\textbf{Inv}, a language that is composed only of partial injective functions. The language has an
operational semantics based on relations and converses. They provide a variety of examples of the
language, including translations from XML to HTML and simple functions such as $wrap$, which wraps
its argument into a list. They continue by describing how non-injective functions may be converted to
injective ones in \textbf{Inv} via the addition of logging. In fact, they use this logging to argue
the language is equivalent in terms of power to the reversible Turing machine of
\cite{bennett:1973reverse}.

The approach of Mu et.al. is a good example of a specific case which is describable by the theory
presented in this Thesis. Their approach of insisting on injective functions is a specific case of
an inverse category. When given two functions $f,g$ of \textbf{Inv}, constructing their union,
$f\union g$ requires that both $\dom f \intersection \dom g = \nothing$ and $\rng f \intersection \rng g =
\nothing$. This is an explicit creation of a disjoint join as introduced in
Section~\ref{sec:disjoint_joins}.

A more recent entry into the field of reversible languages is that of Theseus,
\cite{james2014theseus}, by Sabry and James. Theseus is a functional language which compiles to
$\Pi^0$ as presented in \cite{james2013isomorphic}. The language $\Pi^0$ is based on $\Pi$
\cite{james2012information}.  $\Pi$ is a graphical language for reversible computation, based on
isomorphisms of finite sums and products of types. Their chosen isomorphisms include commutativity
and associativity for sums and products, units for product and distributivity of product over
sums. $\Pi^0$ extends this with recursive types and looping operators and therefore introduces partiality
due to the possibility of non-terminating loops.

The basis of $\Pi^0$ is reminiscent of what we produce in this thesis, however, our approach differs
significantly in focusing first on partiality and the expressiveness this gives us, rather than
building a specific language.


Finally, we note there are a number of quantum programming languages which, as noted, included
reversible operations. Our first example is LQPL \cite{giles2007}, a compiled language based on the
semantics of \cite{selinger04:qpl}. The language includes a variety of reversible operations
(unitary transforms) as primitives, a linear type system and an operational semantics. A more recent
entry is Quipper, \cite{green2013introduction,green2013quipper} a language embedded in Haskell
\cite{peyton2003:haskell98}. Quipper uses quantum \emph{and} classical circuits as an underlying
model. An interesting aspect of reversibility in Quipper is the inclusion of an operator to compute
the reverse of a given circuit.

\section{Objectives}
\label{sec:objectives}

Based upon our review of current research as noted in Section~\ref{sec:background}, reversibility
lacks a unifying semantic model. Standard computing has Cartesian closed categories
\cite{barr:ctcs}, while quantum computing has had much success with dagger compact closed categories
\cite{selinger04:towardssemantics,selinger05:dagger,abramsky05:abstractscalars}.

In this thesis, we will present a type of restriction category which abstracts partial reversible
computations in as general a way as possible. We will show this category admits product-like and
sum-like structures. We will also show this type of restriction category is equivalent to a specific
type of Cartesian restriction category, showing there is a relation to standard computing models.

\section{Contributions}
\label{sec:contributions}

The initial contribution of this thesis is the characterization of inverse categories with
restriction products and restriction coproducts.  We show in
Proposition~\ref{prop:an_inverse_category_with_products_is_a_restriction_preorder} and
Proposition~\ref{prop:inverse_category_with_coproducts_is_pre-order} that each of products and
coproducts impose a trivialization of the structure of the base category.

The main contributions of this thesis are:
\begin{enumerate}
\item The definition and characterization of the inverse product in an inverse category (known as a
  discrete inverse category) and showing  that it provides meets for the inverse category.
\item The creation of an equivalence relation on a discrete inverse category and showing that the
  category resulting from factoring out the equivalence relation is a discrete Cartesian restriction
  category.\label{item:contribution-2}
\item Showing that the category of discrete inverse categories is equivalent to the category of
  discrete Cartesian restriction categories.
\item The development of disjointness relations and disjoint joins in inverse categories and how
  they arise from suitable monoids over the inverse category.
\item Showing that inverse categories with disjoint joins and restriction zeroes (called inverse sum
  categories) give rise to a matrix category and that the original inverse sum category is
  equivalent to the matrix category.
\item The proof that a distributive inverse category (one with inverse products and disjoint joins
  where the inverse product distributes over the disjoint join) gives a distributive restriction
  category when factoring out the equivalence relation from Item~\ref{item:contribution-2} above.
\end{enumerate}

\section{Outline} % (fold)
\label{sec:outline}

We assume a knowledge of basic algebra including definitions and properties of groups, rings,
fields, vector spaces and matrices. The reader may consult \cite{lang:algebra} if further details
are needed.

Chapter~\ref{chap:semantics_in_categories} introduces the various concepts that will be used
throughout this thesis. The basics of category theory are reviewed in Section~\ref{sec:categories}
followed by an introduction to restriction categories in
Section~\ref{sec:restriction_categories}.

Chapter~\ref{cha:inverse_categories} starts with showing that inverse categories with a restriction
product collapses to a restriction pre-order, that is, all parallel maps agree wherever they are
both defined. Section~\ref{sec:inverse_products} introduces the concept of inverse products and
explores the properties of the inverse product. We call inverse categories with
inverse products \emph{discrete inverse categories}. A major example of discrete inverse
categories, commutative Frobenius algebras, is then introduced in
Section~\ref{sec:the_category_of_commutative_frobenius_algebras}.

Chapter~\ref{chap:completing_a_discrete_inverse_category} then presents how to construct a Cartesian
restriction category based on a discrete inverse category.
Section~\ref{sec:equivalence_classes_of_maps_in_hypx} presents the details of the equivalence
relation which gives the maps for the Cartesian restriction category, while
Section~\ref{sec:the_restriction_category_hypxt} and
Section~\ref{sec:the_category_hypxt_is_cartesian} give the proof that it is a Cartesian restriction
category. Section~\ref{sec:equivalence_of_categories} culminates in
Theorem~\ref{thm:discrete_inverse_categories_are_equivalent_to_discrete_restriction_categories}
giving an equivalence adjunction between discrete inverse categories and discrete Cartesian
restriction categories, which were introduced in
Sub-Section~\ref{sub:discrete_restriction_categories}. We conclude the chapter with a series of
examples of the construction.

Having explored how to introduce a product-like construction in an inverse category,
Chapter~\ref{cha:disjointness_in_inverse_categories} begins the exploration of how to add a
coproduct-like construction. Paralleling the previous chapter, we show that restriction coproducts
impose a restrictive structure on an inverse category. The existence of a restriction
coproduct implies that an inverse category must be a pre-order, i.e., that all parallel maps are
equal. Section~\ref{sec:disjointness_in_an_inverse_category} starts with a quick review of joins in
restriction categories, followed by defining a disjointness relation in an inverse category. We show
that disjointness may be defined on all maps or equivalently only on the restriction idempotents of
the inverse category. This allows us to now define the disjoint join in
Section~\ref{sec:disjoint_joins}.

Chapter~\ref{chap:disjoint_sums} shows how specific conditions on a symmetric monoidal
tensor in an inverse category allow us to define both a disjointness relation and a disjoint join
from that tensor. We conclude this chapter with Section~\ref{sec:disjointness_in_frobenius_algebras}
which expands the example of commutative Frobenius algebras, giving a disjointness relation.

Chapter~\ref{cha:inverse_sum_categories} builds upon the previous chapters to introduce
coproduct-like constructions into the inverse
category.  In
Section~\ref{sec:inverse_sum_categories} we explore the relationship between disjoint joins and
inverse sums. This culminates in showing that an inverse category \X with a tensor generating disjoint
joins gives rise to a matrix category over \X and that \X is equivalent to its matrix
category. Finally, in Section~\ref{sec:completing_a_distributive_inverse_category} we show that the
construction introduced in Chapter~\ref{chap:completing_a_discrete_inverse_category} also lifts an
inverse sum up to a coproduct and in fact will create a distributive restriction category when the
inverse product distributes over the disjoint join.

Our conclusions and thoughts for potentially interesting areas to explore further are then given in
Chapter~\ref{cha:conclusions_and_future_work}.



% section algebraic_setting (end)
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../phd-thesis"
%%% End:
