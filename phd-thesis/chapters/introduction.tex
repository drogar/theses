%!TEX root = /Users/gilesb/UofC/thesis/phd-thesis/phd-thesis.tex
\chapter{Introduction}\label{chap:introduction}
\section{Summary}\label{sec:summary}
A ``quantum'' setting has a fundamental duality given by the ``dagger'' of dagger
categories\cite{selinger05:dagger,abramsky05:abstractscalars}. On the other hand, classical
computation is fundamentally asymmetric and has no duality. In passing from a quantum setting to a more classical setting, one
may want to keep this duality for as long as possible and, thus, consider the intermediate step of
passing to ``reversible'' computation --- which has an obvious self-duality given by the ability to
reverse the computation. It is reasonable to
wonder whether one can then pass from a reversible setting to a classical setting quite
independently from the underlying quantum setting. Such an abstract
passage would allow a direct translation into the reversible world of the classical notions of
computation, for example.

Of course, from a quantum setting, it is already possible to pass directly to a classical setting by
taking the homomorphisms between special coalgebras, where ``special'' means the coalgebra must be
the algebra part of a separable Frobenius algebra. That the coalgebra should be special in this manner
may be justified by regarding this as a two step process through reversible computation. However,
this leaves some gaps: How does on pass, in general, between a quantum setting to a reversible
setting and how does one obtain a classical setting from a reversible setting? This thesis answers
those questions.
\section{Background}
\label{sec:background}

Reversible computing, at the level of Turing machines, was shown to be equivalent to standard
computing by Bennet \cite{bennett:1973reverse} in 1973. Since approximately 2000, there has
been an increased interest in reversible computing, as evidenced by the number of papers found in
internet searches. (This may have been engendered by the obvious relationship
to Quantum computing (e.g., \cite{neilsen2000:QuantumComputationAndInfo}) where computation is done
by a series of unitary transforms, each of which is reversible, followed by an irreversible
measurement.)

The semantics of reversible computing has been examined in a variety of ways. Broadly, the research
may be broken into two classes. The first class consists of those that introduce a reversible
language and then describe the semantics of that language in some way. Examples of this include:
Zuliani \cite{zuliani01:reversibility}, the quantum Guarded Command Language which has a reversible
operational semantics; Mu et.al. \cite{muetal04:injreversible}, the language \textbf{Inv} composed
of partial injective functions and Sabry and James \cite{james2014theseus}, the language Theseus
based on isomorphisms of finite sums and products of types. The second class focuses on some
algebraic model and then introduces reversibility to that model. Examples of this include Abramsky
\cite{abramsky05:reversible} with Linear Combinatory Algebras, Di Pierro
et.al. \cite{DiPierro200625} with Combinatory Algebras, Danos and Krivine \cite{danos2004reversible}
who extend CCS\cite{milner1980calculus} to Reversible CCS (RCCS) and Phillips and Uladowski
\cite{phillips2006operational} with an alternate approach to RCCS.


An important aspect of the treatment of reversible computing is the consideration of partiality in
programs, i.e., it is possible for programs to not return an answer for certain inputs. The above
references consider partiality to a greater or lesser degree, but none of them treat it as a central
consideration.

Partiality was shown to have an algebraic treatment, restriction categories, by Cockett and Lack in
\cite{cockett2002:restcategories1,cockettlack2003:restcategories2,cockettlack2004:restcategories3}. The
algebraic treatment consists of an operator on maps, denoted by a bar over the map, such that for a
map $f:A\to B$ in a category, then $\rst{f}:A\to A$ is an idempotent map in the category. Full
details are given here in Chapter~\ref{chap:restriction_categories}.

In much of the research on reversibility, specific conditions are placed on some aspect of the
computational model or reversible language to ensure ``programs'' in this model are reversible.
The variety of models and languages tends to obscure the fundamental commonality of reversibility.
We contend that our treatment of the theory of reversibility will provide clarification allowing one
to see the relationships between a variety of approaches.

\subsection{Algebraic models of reversibility}
\label{subsec:algebraic_models_of_reversibility}
In \cite{abramsky05:reversible}, Abramsky considers linear logic as his computational model. This is
done by producing a Linear Combinatory Algebra \cite{abramsky02:GOI} from the involutive maps over a
term algebra and showing these are bi-orthogonal automata. (An automata is considered orthogonal if
it is non-ambiguous and left-linear. It is bi-orthogonal when both the automata and its converse are
both orthogonal).

In \cite{danos2004reversible}, Danos and Krivine extend CCS (Calculus for Communicating Systems)
\cite{milner1980calculus,milner1989communication} to produces RCCS, which adds reversible
transitions to CCS. This is done by adding a syntax for backtracking, together with a labelling
which guides the backtracking. The interesting aspect of this paper is the applicability to
multi-processor programs.

Phillips and Uladowski \cite{phillips2006operational} take a different approach to creating a
reversible CCS from that of Danos and Krivine. Rather, their stated goal is to use a structural
approach, inspired by \cite{abramsky05:reversible}. The paper is only an initial step in this
process, primarily explaining how to turn dynamic rules (such as choice operators) into a series of
static rules that keep all the information of the input. For example (from the paper), in standard
CCS, we have the rule
\[
  \infer{X+Y \to X'}{X\to X'}.
\]
To preserve information and allow reversibility, this is replaced with
\[
  \infer{X+Y \to X' +Y}{X\to X'}.
\]


\subsection{Reversible languages}
\label{subsec:reversible_languages}

Early examples of reversible languages include Janus \cite{lutz1986janus}, an imperative language
written as an experiment in producing a language that did not erase information. However, it does
not appear that any semantics were developed for this language.

Additionally, there are special purpose reversible languages, such as biXid \cite{bixid06}, a
language developed explicitly to transform XML \cite{xml} from one schema to another. The main
novelty of biXid is that a single program targets two schemas and will transform in either direction.

In the realm of languages which possess an explicit semantics, we start with Zuliani
\cite{zuliani01:reversibility}, who examines logical reversibility via comparing the probabilistic
Guarded Command Language ($pGCL$) \cite{MorganIver99} to the quantum Guarded Command Language
($qGCL$) \cite{sanders:quantum}. Zuliani provides a method for transforming an irreversible $pGCL$
program into a reversible one. This is accomplished via an application of expectation transform
semantics to the $pGCL$ program. Interestingly, in this work, partial programs are specifically
excluded from the definition of reversible programs. The initial definition of a reversible program
is strict, i.e., the program is equivalent to $skip$ which does nothing. To alleviate this and allow
us to extract the output, Zuliani follows the example of \cite{bennett:1973reverse} and modifies the
result so that the output is copied before reversing the rest of the program.

In \cite{mu06bidirectional} and \cite{muetal04:injreversible}, Mu et.al. introduce the language
\textbf{Inv}, a language that is composed only of partial injective functions. The language has an
operational semantics based on determinate relations and converses. They provide a variety of examples of the
language, including translations from XML to HTML and simple functions such as $wrap$, which wraps
its argument into a list. They continue by describing how non-injective functions may be converted to
injective ones in \textbf{Inv} via the addition of logging. In fact, they use this logging to argue
the language is equivalent in terms of power to the reversible Turing machine of
\cite{bennett:1973reverse}.

The approach of Mu et.al. is a good example of a specific case which is describable by the theory
presented in this Thesis. Their approach of insisting on injective functions is a specific case of
an inverse category. When given two functions $f,g$ of \textbf{Inv}, constructing their union,
$f\union g$ requires that both $\dom f \intersection \dom g = \nothing$ and $\rng f \intersection \rng g =
\nothing$. This is an explicit creation of a disjoint join as introduced in
Section~\ref{sec:disjoint_joins}.

A more recent entry into the field of reversible languages is that of Theseus,
\cite{james2014theseus}, by Sabry and James. Theseus is a functional language which compiles to
a graphical language \cite{james2013isomorphic,james2012information} for reversible computation, based on
isomorphisms of finite sums and products of types. Their chosen isomorphisms include commutativity
and associativity for sums and products, units for product and distributivity of product over
sums. The basic graphical language is extended with recursive types and looping operators and
therefore introduces partiality due to the possibility of non-terminating loops.

The basis of Theseus is reminiscent of what we produce in this thesis, however, our approach differs
significantly in focusing first on partiality and the expressiveness this gives us, rather than
building a specific language.


Finally, we note there are a number of quantum programming languages which, as noted, included
reversible operations. Our first example is LQPL \cite{giles2007}, a compiled language based on the
semantics of \cite{selinger04:qpl}. The language includes a variety of reversible operations
(unitary transforms) as primitives, a linear type system and an operational semantics. More recently
Quipper \cite{green2013introduction,green2013quipper}, which focuses on methods to handle very large
circuits, is a language embedded in Haskell \cite{peyton2003:haskell98}. Quipper uses quantum
\emph{and} classical circuits as an underlying model. An interesting aspect of reversibility in
Quipper is the inclusion of an operator to compute the reverse of a given circuit.

\section{Objectives}
\label{sec:objectives}

We intend to propose a categorical semantics for reversible computing. Based upon our review of
current research as noted in Section~\ref{sec:background}, reversibility lacks a unifying semantic
model. Standard computing has Cartesian closed categories \cite{barr:ctcs}, while quantum computing
has had much success with dagger compact closed categories
\cite{selinger04:towardssemantics,selinger05:dagger,abramsky05:abstractscalars}.

In this thesis, we will present a type of restriction category which abstracts partial reversible
computations in as general a way as possible. We will show this category admits product-like and
sum-like structures. We will also show this type of restriction category is equivalent to a specific
type of Cartesian restriction category, showing there is a relation to standard computing models.

\section{Contributions}
\label{sec:contributions}


The main contributions of this thesis are:
\begin{enumerate}
\item The characterization of inverse categories with restriction products and restriction
  coproducts.  We show in
  Proposition~\ref{prop:an_inverse_category_with_products_is_a_restriction_preorder} and
  Proposition~\ref{prop:inverse_category_with_coproducts_is_pre-order} that each of products and
  coproducts impose a trivialization of the structure of the base category.

\item The definition and characterization of the inverse product in an inverse category (known as a
  discrete inverse category) and showing  that it provides meets for the inverse category  in
  Proposition~\ref{prop:discrete_inverse_category_has_meets}. We show that the inverse sub-category
  of a discrete Cartesian restriction category is a discrete inverse category in
  Lemma~\ref{lem:inv_x_is_a_discrete_inverse_category}.
\item The creation of an equivalence relation on a discrete inverse category and show in
  Theorem~\ref{thm:xt_is_a_discrete_crc_when_x_is_an_inverse_category} that the category resulting
  from factoring out the equivalence relation is a discrete Cartesian restriction
  category.\label{item:contribution-2}
\item Showing that the category of discrete inverse categories is equivalent to the category of
  discrete Cartesian restriction categories in
  Theorem~\ref{thm:discrete_inverse_categories_are_equivalent_to_discrete_restriction_categories}.
\item The development of disjointness relations and disjoint joins in inverse categories and how
  they arise from suitable tensors on the inverse category in
  Proposition~\ref{prop:disjointness_tensor_gives_disjoint_join}.
\item Showing that inverse categories with disjoint joins and restriction zeroes give rise to a
  matrix category and that the original disjoint sum category is equivalent to the matrix category
  in Proposition~\ref{pro:x_and_imatx_are_equivalent}.
\item The proof that a distributive inverse category (one with inverse products and disjoint joins
  where the inverse product distributes over the disjoint join) gives a distributive restriction
  category when factoring out the equivalence relation from Item~\ref{item:contribution-2} above in
  Corollary~\ref{cor:xt_is_a_distributive_restriction_category}.
\end{enumerate}

\section{Outline} % (fold)
\label{sec:outline}

We assume a knowledge of basic algebra including definitions and properties of groups, rings,
fields, vector spaces and matrices. The reader may consult \cite{lang:algebra} if further details
are needed.

Chapter~\ref{chap:introduction_to_categories} introduces the various categorical concepts that will
be used throughout this thesis.

Chapter~\ref{chap:restriction_categories} describes restriction categories, an algebraic way to
axiomatize partiality of maps in categories. After introducing restrictions, we discuss joins,
meets, ranges and partial map categories. We describe the product in restriction categories, and
describe discrete Cartesian restriction categories, which will be used through the rest of this
thesis. Various examples of types of restriction categories are given throughout the chapter.


Chapter~\ref{cha:inverse_categories} introduces inverse categories and provides examples of inverse
categories and restriction categories which are not inverse categories. We show that inverse categories with a restriction
product collapses to a restriction pre-order, that is, all parallel maps agree wherever they are
both defined. Then, Section~\ref{sec:inverse_products} introduces the concept of inverse products and
explores the properties of the inverse product. Inverse categories with
inverse products are called \emph{discrete inverse categories}.

Chapter~\ref{chap:completing_a_discrete_inverse_category} then presents the construction of a
Cartesian restriction category from a discrete inverse category.
Section~\ref{sec:equivalence_classes_of_maps_in_hypx} presents the details of the equivalence
relation for the maps for the Cartesian restriction category, while
Section~\ref{sec:the_restriction_category_hypxt} and
Section~\ref{sec:the_category_hypxt_is_cartesian} prove that it is a Cartesian restriction
category. Section~\ref{sec:equivalence_of_categories} culminates in
Theorem~\ref{thm:discrete_inverse_categories_are_equivalent_to_discrete_restriction_categories}
giving an equivalence adjunction between discrete inverse categories and discrete Cartesian
restriction categories. We conclude the chapter with a series of examples of the construction.

Having explored how to introduce a product-like construction for inverse categories,
Chapter~\ref{cha:disjointness_in_inverse_categories} begins the exploration of how to add a
coproduct-like construction. Paralleling the previous chapter, we show the existence of a restriction
coproduct implies that an inverse category must be a pre-order, i.e., that all parallel maps are
equal. Section~\ref{sec:disjointness_in_an_inverse_category} defines a disjointness relation in an inverse category. We show
that disjointness may be defined on all maps or equivalently only on the restriction idempotents of
the inverse category. This allows us to now define the disjoint join in
Section~\ref{sec:disjoint_joins}.

Chapter~\ref{chap:disjoint_sum_tensors} shows how specific conditions on a symmetric monoidal
tensor in an inverse category allow us to define both a disjointness relation and a disjoint join
from that tensor. We conclude this chapter with Section~\ref{sec:disjointness_in_frobenius_algebras}
which expands the example of commutative Frobenius algebras, giving a disjointness relation.

A major source of examples of discrete inverse
categories is commutative Frobenius algebras. These are discussed in
Chapter~\ref{chap:commutative_frobenius_algebras}. In the chapter, we first provide
a background on dagger categories and frobenius algebras. We then introduce the category of
commutative Frobenius algebras and show that it is a discrete inverse category. Next, we show this
category has a disjointness relation.

Chapter~\ref{cha:matrix_categories} builds upon the previous chapters to introduce
coproduct-like constructions into the inverse
category. We explore the relationship between disjoint joins and
disjoint sums. This culminates in showing that an inverse category \X with a tensor generating disjoint
joins gives rise to a matrix category over \X and that \X is equivalent to its matrix
category.

In Chapter~\ref{sec:distributive_inverse_categories} we show that the
construction introduced in Chapter~\ref{chap:completing_a_discrete_inverse_category} also lifts an
disjoint sum up to a coproduct and in fact will create a distributive restriction category when the
inverse product distributes over the disjoint join.

Our conclusions and thoughts for potentially interesting areas to explore further are then given in
Chapter~\ref{cha:conclusions_and_future_work}.



% section algebraic_setting (end)
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../phd-thesis"
%%% End:
