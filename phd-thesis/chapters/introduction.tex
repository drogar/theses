%!TEX root = /Users/gilesb/UofC/thesis/phd-thesis/phd-thesis.tex
\chapter{Introduction}
\section{Background}
\label{sec:background}

Reversible computing, at the level of Turing machines, was shown to be equivalent to standard
computing by Bennet \cite{bennett:1973reverse} in 1973. In the past fifteen or so years, there has
been an increased interest in reversible computing, perhaps engendered by the obvious relationship
to Quantum computing (e.g., \cite{neilsen2000:QuantumComputationAndInfo}) where computation is done
by a series of unitary transforms, each of which is reversible, followed by an irreversible
measurement.

The semantics of reversible computing has been examined in a variety of ways. Broadly, they may be
broken into two classes. The first class consists of those that introduce a reversible
language and then describe the semantics of that language in some way. Examples of this include
Zuliani, \cite{zuliani01:reversibility} and Mu et.al., \cite{muetal04:injreversible}. The second
class focus on some algebraic model and then introduce reversibility to that model. Examples of this
include Abramsky \cite{abramsky05:reversible}, Di Pierro et.al. \cite{DiPierro200625}, Danos and
Krivine \cite{danos2004reversible} and Phillips and Uladowski \cite{phillips2006operational}.

An important aspect of the treatment of reversible computing is the consideration of partiality in
programs, i.e., it is possible for programs to not return an answer for certain inputs. The above
references consider partiality to a greater or lesser degree, but none of them treat it as a central
consideration.

Partiality was shown to have an algebraic treatment, restriction categories, by Cockett and Lack in
\cite{cockett2002:restcategories1,cockettlack2003:restcategories2,cockettlack2004:restcategories3}. The
algebraic treatment consists of an operator $(\rst{~})$ on maps such that for a map $f:A\to B$ in a
category, then $\rst{f}:A\to A$ is an idempotent map in the category. Full details are given here in
Section~\ref{sec:restriction_categories}.

In much of the research on reversibility, specific conditions are placed on some aspect of the
computational model or reversible language to ensure ``programs'' in this model are reversible. Due
to the variety of models and languages it is unclear what are the common threads of these restrictions.
We contend that our treatment of the theory of reversibility will provide the basis to show the
relationships of the variety of approaches.

\subsection{Algebraic models of reversibility}
\label{subsec:algebraic_models_of_reversibility}
In \cite{abramsky05:reversible}, Abramsky considers bi-orthogonal automata as his computational
model. (An automata is considered orthogonal if it is non-ambiguous and left-linear. It is
bi-orthogonal when both the automata and its converse are both orthogonal). Abramsky then builds a
bridge from partial injective and involutive functions to these automata. To show universality,
specific constructions of bi-orthogonal automata are provide which create a Linear Combinatory Algebra
\cite{abramsky02:GOI}.

In \cite{danos2004reversible}, Danos and Krivine extend CCS (Calculus for Communicating Systems)
\cite{milner1980calculus,milner1989communication} to produces RCCS, which adds reversible
transitions to CCS. This is done by adding a syntax for backtracking, together with a labelling
which guides the backtracking. The interesting aspect of this paper is the applicability to
multi-processor programs.

Phillips and Uladowski \cite{phillips2006operational} take a different approach to creating a
reversible CCS from that of Danos and Krivine. Rather, their stated goal is to use a structural
approach, inspired by \cite{abramsky05:reversible}. The paper is only an initial step in this
process, primarily explaining how to turn dynamic rules (such as choice operators) into a series of
static rules that keep all the information of the input. For example (from the paper), in standard
CCS, we have the rule
\[
  \infer{X+Y \to X'}{X\to X'}.
\]
To preserve information and allow reversibility, this is replaced with
\[
  \infer{X+Y \to X' +Y}{X\to X'}.
\]


\subsection{Reversible languages}
\label{subsec:reversible_languages}

Early examples of reversible languages include Janus \cite{lutz1986janus}, an imperative language
written as an experiment in producing a language that did not erase information. There were not
attempts made at creating a semantics for this language, as far as we know.

Additionally, there are special purpose reversible languages, such as biXid \cite{bixid06}, a
language developed explicitly to transform XML \cite{xml} from one schema to another. The main
novelty of biXid is that a single program targets two schemas and will transform in either direction.

In the realm of languages which posses an explicit semantics, we start with Zuliani
\cite{zuliani01:reversibility}, who examines logical reversibility via extending $pGCL$
\cite{MorganIver99} and comparing to $qGCL$ \cite{sanders:quantum}. Zuliani provides a method for
transforming an irreversible $pGCL$ program into a reversible one. This is accomplished via an
application of expectation transform semantics to the $pGCL$ program. Interestingly, partial
programs are specifically excluded from the definition of reversible programs. The initial
definition of a reversible program is initially strict, i.e., the program is equivalent to $skip$
which does nothing. To alleviate this and allow us to extract the output, he follows the example of
\cite{bennett:1973reverse} and modifies the result so that the output is copied before reversing the
rest of the program.

In \cite{mu06bidirectional} and \cite{muetal04:injreversible}, Mu et.al. introduce the language
\textbf{Inv}, a language that is composed only of partial injective functions. The language has an
operational semantics based on relations and converses. They provide a variety of examples of the
language, including translations from XML to HTML and simple functions such as $wrap$, which wraps
its argument into a list. Additionally they describe how non-injective functions may be converted to
injective ones in \textbf{Inv} via the addition of logging. In fact, they use this logging to argue
the language is equivalent in terms of power to the reversible Turing machine of
\cite{bennett:1973reverse}.

The approach of Mu et.al. is a good example of a specific case which is describable by the theory
presented in this Thesis. Their approach of insisting on injective functions is a specific case of
an inverse category. When given two functions $f,g$ of \textbf{Inv}, constructing their union,
$f\cup g$ requires that both $\dom f \cap \dom g = \nothing$ and $\rng f \cap \rng g =
\nothing$. This is an explicit creation of a disjoint join as introduced in
Section~\ref{sec:disjoint_joins}.

A more recent entry into the field of reversible languages is that of Theseus,
\cite{james2014theseus}, by Sabry and James. Theseus is a functional language which compiles to
$\Pi^0$ as presented in \cite{james2013isomorphic} which is based on $\Pi$
\cite{james2012information}.  $\Pi$ is a graphical language for reversible computation, based on
isomorphisms of finite sums and products of types. Their chosen isomorphisms include commutativity
and associativity for sums and products, units for product and distributivity of product over
sums. $\Pi^0$ extends this with recursive types and looping operators. $\Pi^0$ introduces partiality
due to the possibility of non-terminating loops.

The basis of $\Pi^0$ is reminiscent of what we produce in this thesis, however, our approach differs
significantly in focusing first on partiality and the expressiveness this gives us, rather than
building a specific language.


Finally, we note there are a number of quantum programming languages which, as noted, included
reversible operations. Our first example is LQPL \cite{giles2007}, a compiled language based on the
semantics of \cite{selinger04:qpl}. The language includes a variety of reversible operations
(unitary transforms) as primitives, a linear type system and an operational semantics. A more recent
entry is Quipper, \cite{green2013introduction,green2013quipper} a language embedded in Haskell
\cite{peyton2003:haskell98}. Quipper uses quantum \emph{and} classical circuits as an underlying
model. An interesting aspect of reversibility in Quipper is the inclusion of an operator to compute
the reverse of a given circuit.

\section{Objectives}
\label{sec:objectives}

Based upon our review of current research as noted in Section~\ref{sec:background}, reversibility
lacks a unifying semantic model. Standard computing has Cartesian closed categories
\cite{barr:ctcs}, while quantum computing has had much success with dagger compact closed categories
\cite{selinger04:towardssemantics,selinger05:dagger,abramsky05:abstractscalars}.

In this thesis, we will present a type of restriction category which abstracts partial reversible
computations in as general a way as possible. We will show this category admits product-like and
sum-like structures. We will also show this type of restriction category is equivalent to a specific
type of Cartesian restriction category, showing there is a relation to standard computing models.

\section{Contributions}
\label{sec:contributions}

The initial contribution of this thesis is the characterization of inverse categories with products
and coproducts.
We show in Proposition~\ref{prop:an_inverse_category_with_products_is_a_restriction_preorder}
and Proposition~\ref{prop:inverse_category_with_coproducts_is_pre-order} that each of products and
coproducts impose a trivialization of the structure of the base category.

The main contributions of this thesis are:
\begin{enumerate}
\item The definition and characterization of the inverse product in an inverse category (known as a
  discrete inverse category) and showing  that it provides meets for the inverse category.
\item The creation of an equivalence relation on a discrete inverse category and showing that the
  category resulting from factoring out the equivalence relation is a discrete Cartesian restriction
  category.\label{item:contribution-2}
\item Showing that the category of discrete inverse categories is equivalent to the category of
  discrete Cartesian restriction categories.
\item The development of disjointness relations and disjoint joins in inverse categories and how
  they arise from suitable monoids over the inverse category.
\item Showing that inverse categories with disjoint joins and restriction zeroes (called inverse sum
  categories) give rise to a matrix category and that the original inverse sum category is
  equivalent to the matrix category.
\item The proof that a distributive inverse category (one with inverse products and disjoint joins
  where the inverse product distributes over the disjoint join) gives a distributive restriction
  category when factoring out the equivalence relation from Item~\ref{item:contribution-2} above.
\end{enumerate}

\section{Outline} % (fold)
\label{sec:outline}

We assume a knowledge of basic algebra including definitions and properties of groups, rings,
fields, vector spaces and matrices. The reader may consult \cite{lang:algebra} if further details
are needed.

Chapter~\ref{chap:abstract_computability} introduces the various concepts that will be used
throughout this thesis. The basics of category theory are reviewed in Section~\ref{sec:categories}
followed by an introduction to restriction categories in
Section~\ref{sec:restriction_categories}. Section~\ref{sec:daggercategories} and
Section~\ref{sec:frobenius_algebras}  introduce dagger categories and Frobenius
algebras respectively. These constructs are of particular interest in the study of quantum semantics
and will provide a source of examples for us.

Chapter~\ref{cha:inverse_categories} starts with showing that inverse categories with a restriction
product collapse into a restriction pre-order, that is, all parallel maps agree wherever they are
both defined. Section~\ref{sec:inverse_products} introduces the concept of inverse products and
explores the properties of inverse categories with these constructions. Inverse categories with
inverse products are labelled discrete inverse categories. A major example of discrete inverse
categories, commutative Frobenius algebras is then introduced in
Section~\ref{sec:the_category_of_commutative_frobenius_algebras}.
Section~\ref{sec:completing_a_discrete_inverse_category} then explores how to construct a Cartesian
restriction category based on a discrete inverse category, culminating in
Theorem~\ref{thm:discrete_inverse_categories_are_equivalent_to_discrete_restriction_categories}
giving an equivalence adjunction between discrete inverse categories and discrete Cartesian
restriction categories, which were introduced in Sub-Section~\ref{sub:discrete_restriction_categories}.

Having explored how to introduce a product-like construction in an inverse category,
Chapter~\ref{cha:disjointness_in_inverse_categories} begins the exploration of how to add a
coproduct-like construction. Paralleling the previous chapter, in
Section~\ref{sec:coproducts_in_restriction_categories} we show that restriction coproducts
impose an even greater amount of structure on an inverse category. The existence of a restriction
coproduct implies that an inverse category must be a pre-order, i.e., that all parallel maps are
equal. Section~\ref{sec:disjointness_in_an_inverse_category} starts with a quick review of joins in
restriction categories, followed by defining a disjointness relation in an inverse category. We show
that disjointness may be defined on all maps or equivalently only on the restriction idempotents of
the inverse category. This allows us to now define the disjoint join in
Section~\ref{sec:disjoint_joins}. We then conclude this chapter with
Section~\ref{sec:tensors_for_disjointness} showing how specific conditions on a symmetric monoidal
tensor in an inverse category allow us to define both a disjointness relation and a disjoint join
from that tensor.

Chapter~\ref{cha:inverse_sum_categories} builds upon the previous chapters to introduce
coproduct-like constructions into the inverse
category. Section~\ref{sec:disjointness_in_frobenius_algebras} starts by expanding the example of
commutative Frobenius algebras, showing there is a disjointness relation in them. In
Section~\ref{sec:inverse_sum_categories} we explore the relationship between disjoint joins and
inverse sums. This culminates in showing that an inverse category \X with a tensor generating disjoint
joins gives rise to a matrix category over \X and that \X is equivalent to its matrix
category. Finally, in Section~\ref{sec:completing_a_distributive_inverse_category} we show that the
construction introduced in Section~\ref{sec:completing_a_discrete_inverse_category} also lifts an
inverse sum up to a coproduct and in fact will create a distributive restriction category when the
inverse product distributes over the disjoint join.

Our conclusions and thoughts for potentially interesting areas to explore further are then given in
Chapter~\ref{cha:conclusions_and_future_work}.



% section algebraic_setting (end)
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../phd-thesis"
%%% End:
