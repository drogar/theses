
\section{Transforming between the states}\label{sec:statetransforming}



As introduced in \vref{sec:qsmstate}, we use three different 
state descriptions for our transition diagrams.
They are:
\begin{gather*}
\bms = (\cd,S,L(Q),D,N)\\
\cms = (\cd, C , [(S,L(Q),D,N)])\\
\ms = \il{(\cd, C , [(S,L(Q),D,N)])} 
\end{gather*}

For this to work, we provide lifting maps that allow a map in \bms{}
to be lifted to \cms{} and then to \ms{}.

\subsection{Lifting \bms{} to \cms}\label{subsec:liftbmstocms}


A function $f::\bms\to\bms$ will be transformed to an
endomorphism of \cms{} by applying it across 
the list of $(S,L(Q),D,N)$ tuples.
This works, 
\emph{provided $f$ is not operating on element from the control stack}. As 
will be shown in the section on code generation, 
\vref{sec:translationtoqsmcode},
the code generated by the \lqpl{} compiler complies with this restriction.

Suppose we have $f$ as above. Then, the function
\begin{equation}
toCms \circ app2\ (cMmap\ f) \circ toBms'\label{eq:liftingofbmsmap}
\end{equation}
is the  lifting of $f$ to \cms.
The  maps $toBms'$ and $toCms$ are defined as:
\begin{align}
  toBms'\ (c, ctl , sqdls) &= (ctl , 
map\ (p1to4\ c)\ sqdls)\label{eq:toBmscode}\\
  toCms\ (c, csqdls) &= (fstof5\ (head\ csqdls), ctl , 
map\ (last4Of5)\ csqdls)\label{eq:toCmscode}
\end{align}
The definition of $toBms'$ in \vref{eq:toBmscode} shows that it 
transforms an element of \cms{} to a pair consisting of the control
for the \cms{} element and a list of tuples. The tuples are almost
\bms{} elements, with the exception that the quantum stack retains its
control labeling.\footnote{The actual implementation does
make use of another type, BMS' which is defined the same way as BMS
but without labeled quantum stacks. See \vref{sec:QSM:machinestate}.}
The definition of $toCms$ reverses this transformation, taking the pair
of a control list and list of tuples back to an element of \cms.
In the definition of $toCms$, the
 function $map$ is defined as the standard list mapping function,
\begin{equation*}
map\ f\ [a_1,a_2,\ldots,a_n] = [f\ a_1,f\ a_2,\ldots,f\ a_n]
\end{equation*}

For any  $f::\bms \to \bms$, we may write it as:
\begin{equation}
f\ (cd, s, q, d, n) = (f_c\ cd,f_s\ s,f_q\ q, f_d\ d, f_n\ n)\label{eq:basemap}
\end{equation}

Then, the definition of $cMmap$ used in \vref{eq:liftingofbmsmap}
may be given as:
\begin{equation}
cMmap\ f = map\ (lift\ f)\label{eq:cmmap}
\end{equation}
where $map$ is defined as above and $lift$ is given by:
\begin{equation*}
lift\ f\ (cd,s, (lbl\ q), d, n) = (f_c\, cd,f_s\, s,(lbl\, (f_q\, q)), f_d\, d, f_n\, n)
\end{equation*}

Various tuple manipulation functions were used in the  above definitions as
well. Their definitions are:
\begin{align*}
  app2\ f\ (a,b) &= (a, f\, b)\\
  p1to4\ a\ (b,c,d,e) &= (a,b,c,d,e) \\
  fstof5\ (a,b,c,d,e) &= a \\
  last4of5\ (a,b,c,d,e) &= (b,c,d,e)
\end{align*}


\subsection{Lifting \cms{} to \ms}\label{subsec:liftcmstoms}

Our second stage, from \cms{} to \ms{}, makes use of the fact that
the infinite list functor is known to be a monad. Therefore, we may
apply the Kleisli lifting to any map in \cms{} to get a map in \ms{}.

In detail, we have infinite lists are given by the co-inductive type 
defined with destructors $\hd$ that returns the base type and
$\tl$ that returns a new infinite list.
\[\ila=\nu x.\{\hd: A, \tl: x\}\]
Categorically, this corresponds to the diagram in \vref{fig:inflistalgebra} 
which defines infinite lists.
\begin{figure}[htbp]
\[
\xymatrix{
A \ar@{=}[d] &
    C \ar[l]_{h} \ar[r]^{t} \ar@{.>}[d]^{f}&
    C \ar@{.>}[d]^{f}\\
A &
    \ila \ar[l]^{\hd} \ar[r]_{\tl}&
    \ila
 }
\]
\caption{Initial algebra diagram for infinite lists}\label{fig:inflistalgebra}
\end{figure}

Recall that for a monad, given the functor $T$, (which is $\il{\_}$ in
this case) we must supply natural transformations 
$\eta::I\to T, \mu::T^2\to T$ so that the
diagrams in \vref{fig:opstandardmonad} commute.
\begin{figure}[htbp]
\[
\xymatrix{
T^3 \ar[r]^{T\mu} \ar[d]_{\mu T} &
    T^2 \ar[d]^{\mu} \\
T^2 \ar[r]_{\mu} &
    T
 }\quad \mathrm{\ and\ }\quad
\xymatrix{
IT \ar@{=}[dr] \ar[r]^{\eta T} &
    T^2 \ar[d]^{\mu} &
    TI \ar[l]_{T\eta} \ar@{=}[dl]\\
 & T &
 }
\]
\caption{Standard Monad coherence diagrams}\label{fig:opstandardmonad}
\end{figure}

In the case of the infinite list, $\mu=$\emph{diagonal} 
and $\eta=$\emph{constant}, that is:
\begin{gather*}
\mu([[a_{00},a_{01},\ldots],[a_{10},a_{11},\ldots],\ldots]) = 
[a_{00},a_{11},a_{22},\ldots] \\
\eta(a) = [a,a,a,\ldots]
\end{gather*}